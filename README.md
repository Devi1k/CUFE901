# C语言考研

## 考研加油

#### 注意
1. ***程序填空题和程序改错题：找对应变量是否都用到，同时看头文件***  
2. ***读程序题标出每一个printf***  
3. ***改错题注意函数类型***
4. ***各数据类型存储长度:***  
![数据类型](/lengthOfDataType.jpg)  
![数据类型](https://www.runoob.com/wp-content/uploads/2014/09/32-64.jpg)
5. 运算符优先级:  
![优先级](/priority.jpg)
6. 转义字符表:  
![alt 转义字符](/ESC.jpg)
7. 





#### 错题 
1. 字符数组赋值需要strcpy(2006.1.3)  
2. `int a[3][4] = {0},*p = a;`   
    `*(&a[0]+7)=*(a+7);`(表示第七行地址，&a[0]=a)  
    `*a+7`表示第一个元素地址+7(2006.1.5)  
3. 注意结构体内指针的指向(2007.2.3)  
4. 单链表创建(2007.3.2)  
5. 数据库是以记录为界线来区分，C语言没有记录说法(2009.1.19)  
6. \#define 宏 替换体  宏定义中替换体的类型为字符串(2009.1.26)  
7. ++或--的操作数只能是变量，不能是常量或表达式(2009.1.28)  
8. 函数不可以返回一个共用体变量(2009.1.24)  
9. 声明函数时不必明确参数类型(2010.2.2)  
10. 最大公约数求法：   
    1.辗转相减法(更相减损术)：两个数相减，判断差是否为0，若不为0，用小数和差组成新的数对再相减，直至差为0，最后相等的两个数即为最大公约数  
    2.辗转相除法：用除数除以余数，反复直至余数为0
11. 不可以给指针变量赋一个整数，类型不符
12. 形参缺省存储类型为auto
13. C语言的结束可能会在程序中间结束：exit();
14. 强制转换的数据不是常量  强制转换可能会改变值
15. C语言源程序中表示整形常数不使用二进制
16. 实型整形数据指数形式E/e后必须跟有数（整数）  
17. C语言格式控制符会四舍五入  
18. C语句分为  （都需要带分号   复合语句不需要分号  
    1. 表达式语句
        1. 赋值语句（b++;）
        2. 函数调用语句
        3. 空语句
    2. 控制语句
    3. 复合语句
19. `switch(整形表达式){  case 常量: xxxxx  }`且case内常量不能相同，整形表达式不能为空
20. 调用函数，且该函数没有return语句则返回一个不确定的值
21. 变量作实参时，它和对应形参之间的数据传递方式是单向值传递
22. 在函数内的复合语句中定义的变量在本复合语句内有效
23. 浮点常量默认double
24. 函数值类型的定义可以缺省，此时函数值的隐含类型是int
25. 不同类型赋值时，高精度赋给低精度会导致结果不准确，低精度赋给高精度不会有此情况
26. 创建字符数组后，令指针指向后给指针赋值，并不会保存到数组中
27. `char str[][8] = {"first","second"},*p = str[0][0];printf("%s\n",p+8);`  
    输出内容为second，每个字符串占8个char
28. C语言中，构造类型共四种：数组、结构体、共用体、枚举
29. 基本数据类型：单精度，双精度，整形，字符型，枚举
30. 简单数据类型：实型，整形，字符型
31. 字符串中转义字符以十六进制表示时，前面不能加0
32. fabs()求实型绝对值，abs()求整形绝对值  
33. pow函数返回值为double类型   
34. 格式转换符 -表示左对齐  无说明右对齐 格式转换符中，如果有-或者指定精度则忽略0标记  
35. 读入字符时％c    回车也会作为字符读入
36. scanf中的格式转换符不能带小数点
37. 实型小数点后默认六个零  
38. 读取字符数据指定宽度时，系统读取第一个字符  
39. 制表符为七个空格  
40. 枚举常量与数组相同，从0开始；枚举定义：enum a{one,two,three}  
41. 静态数组、变量初始化后，值全部为0
42. 字符数组的内容不一定是字符串（没有\0的不是字符串
43. 数组定义：类型说明 数组名 常量表达式
44. 第一维省略的情况下，用数组内元素个数除以第二维大小。若有余数，则商+1就是第一维的大小，没有余数商就是第一维的大小。
45. 排序算法：
    1. 插入排序  
        假设前n个都是已经排好的，新进来的与每个比较，找到适当位置。  
    算法:  
    ```
        for (i = 1; i < 10; ++i) {
                t = a[i];
                for (j = i - 1; j >= 0 && (a[j] > t); --j) {
                    a[j + 1] = a[j];
                }
                a[j + 1] = t;
            }
    ```   
    2. 冒泡排序  
    ```
		    for (i=0; i<len-1; i++) / 外循环为排序趟数，len个数进行len-1趟 */
	            for (j=0; j<len-1-i; j++) { /* 内循环为每趟比较的次数，第i趟比较len-i次 */
	                if (arr[j] > arr[j+1]) { /* 相邻元素比较，若逆序则交换（升序为左大于右，降序反之） */
	                    temp = arr[j];
	                    arr[j] = arr[j+1];
	                    arr[j+1] = temp;
	                }
	            }
    ```
    3. 二分排序  
    ```
	    for (i = 1; i < len; ++i) {
	        temp = a[i];
	        low = 0;
	        high = i - 1;
	        while (low <= high) {
	            mid = (low + high) / 2;
	            if (a[mid] > temp) {
	                high = mid - 1;
	            } else {
	                low = mid + 1;
	            }
	        }
	        for (j = i - 1; j >= low; --j) {
	            a[j + 1] = a[j];
	        }
	        a[high + 1] = temp;
        }
    ```  
46. 二维数组在内存中的存放顺序是按行主顺序存放
47. 用户可以重新定义标准库函数，且该函数失去原有意义
48. 形参不能为表达式
49. 
